% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/psSort.R
\name{psSort}
\alias{psSort}
\alias{validate_S3.psSort}
\alias{as_psSort}
\alias{as_psSort.psGrid}
\alias{as_psSort.numeric}
\alias{as_psSort.integer}
\alias{as_psSort.data.frame}
\alias{as_psSort.matrix}
\title{Store an \emph{individual} sort as a character matrix of \emph{item handles}}
\usage{
psSort(sort, polygon = "rectangle", offset = NULL)

\method{validate_S3}{psSort}(x, grid = NULL, items = NULL, ...)

as_psSort(obj, ...)

\method{as_psSort}{psGrid}(obj, ...)

\method{as_psSort}{numeric}(obj, ...)

\method{as_psSort}{integer}(obj, ...)

\method{as_psSort}{data.frame}(obj, ...)

\method{as_psSort}{matrix}(obj, grid = NULL, ...)
}
\arguments{
\item{sort}{\code{[matrix()]}
giving the occupying item of cells for sorting as \code{character(1)} strings of \strong{item handles}.
\code{NA} is used for empty \emph{and} disallowed cells (see \link{psGrid}).
The (horizontal) x-axis is assumed to be the sorting direction, the (vertical) y-axis for recording ties.
Dimensions can be named (recommended), giving a short description of the sorting dimension (only applicable to the x-axis).
Row and column \emph{indeces} can also be named, but names are purely cosmetic.}

\item{polygon}{\code{[character(1)]} giving polygon to use for tiling

Must be one of:
\itemize{
\item \code{'rectangle'} (\strong{default}) or
\item \code{'hexagon'}
}}

\item{offset}{\code{[character(1)]} giving the \emph{rows} to be offset.

Must be one of:
\itemize{
\item \code{NULL} in which case no offset is used for a square tiling. (\strong{default})
\item \code{'even'} or
\item \code{'odd'}
}}

\item{x}{An object with one of the pensieve S3 classes.}

\item{grid}{\code{[matrix()]}
giving the availability of cells for sorting as \code{logical(1)} values.
The (horizontal) x-axis is assumed to be the sorting direction, the (vertical) y-axis for recording ties.
Dimensions can be named (recommended), giving a short description of the sorting dimension (only applicable to the x-axis).
Row and column \emph{indeces} can also be named, but names are purely cosmetic.}

\item{items}{\code{[character()]} giving the \emph{participant-facing} \strong{item content}.
Can be named to provide short, \emph{researcher-facing} \strong{item handles}.
\itemize{
\item if \code{dir_bin} is \code{NULL} (default), \code{items} must be text.
Items can be marked up using \href{https://rmarkdown.rstudio.com/authoring_pandoc_markdown.html}{Pandoc Markdown}.
An additional subclass \code{psItemContentText} is prepended and validated.
\item if \code{dir_bin} is given, \code{items} must be file paths, relative from \code{dir_bin}.
An additional subclass \code{psItemContentBin`` is prepended and validated.}lang\code{,}fontsize_global\code{,}alignment\code{and}linestretch` are ignored.
}}

\item{...}{further arguments to be passed to methods.}

\item{obj}{An object which can be coerced to a character matrix of class \link{psSort}.}
}
\value{
A character matrix of class \link{psSort}.
}
\description{
Stores \emph{one} sort, by one participant as an \eqn{i * k} character matrix, with sorting columns as columns, sorting rows as rows and \emph{short item handles} (see \code{psItems}) in cells.
}
\details{
Sorts can be stored in the form in which they were originally created on a table or in a computer user interface.
The \code{y}-axis, though meaningless (ties) in most studies, is also stored, but this full matrix form makes it easy to reason about the data, and to validate it.
}
\section{Methods (by generic)}{
\itemize{
\item \code{validate_S3}: Validation

\item \code{as_psSort}: Coercion from \link{psGrid} (sets all to \code{NA})

\item \code{as_psSort}: Coercion from integer(ish) vector of item positions; names are retained as item handles.

\item \code{as_psSort}: Coercion from a long dataframe with \code{x}/\code{y} item positions as first/second columns, and \strong{item handles} as third column.

\item \code{as_psSort}: Coercion from a matrix similar to \link{psSort}, in accordance with a \link{psGrid} in \code{grid}:
\itemize{
\item Will place smaller matrices in bigger matrices.
\item Will fill in only \emph{allowed} cells from the bottom (highest row) up.
}
}}

\section{Hexagonal tiling}{

\link{psGrid} and \link{psSort} store \emph{all} sorting grids as \emph{rectangular} matrices, using what is known as the \href{https://www.redblobgames.com/grids/hexagons/}{"offset" notation for hexagonal tiling}.
In offset notation, hexagonal tilings are saved as if they were normal (square) tilings, with an additional attribute giving which rows are to be offset.
In this way, both square and hexagonal tilings can be stored in a similar format.
They are also intuitive to use, where the outer limits of the tiling are rectangular, and rotation is not required, both of which are usually the case for sorting.
However, linear algebra operations are no longer defined on such hexagonal matrices in offset notation (that would require cube or axial coordinates).
Remember not to run such operations on hexagonally tiled \link{psGrid}s or \link{psSort}s.

The \code{offset} argument is used to switch between loosely defined tiling patterns.
Strictly speaking there are  \emph{three regular} tiling patterns: square, hexagonal and triangular.
However, items are more easily typeset in \emph{rectangles} than in squares, hexagons or triangles.
You can therefore also use "square" tiling (\code{offset = NULL}) for rectangulary set items, and even "hexagonal" tiling (\code{offset = "even"} or \code{offset = "odd"}) for rectangles (in a "brickwall" pattern) and irregular (stretched or squeezed) hexagons.
One combination remains impossible: you cannot have "square" tiling (\code{offset = NULL}) with hexagons (\code{polygon = 'hexagon'}).

The aspect ratio of the \emph{irregular} polygons is currently only provided to respective \code{knit_print()} methods.
To achieve \emph{regular} square and hexagonal tiling (though this is unlikely to be useful), set \code{aspect_ratio_cards} to \code{1}.

Notice that \code{offset} always refers to \emph{rows}, and as such implies hexagonal tiling in "\strong{pointy}"-topped rotation.

Remember that rows for \code{offset} are given using \emph{R} indices, starting with \code{1}.
Examples of offset notation in most other programming languages will differ."
}

\examples{
# create simple grids ====

# make simple matrix by hand
m <- matrix(data = c(FALSE, TRUE, TRUE, TRUE, FALSE, TRUE), nrow = 2)
grid_byhand <- psGrid(grid = m)

# matrix with better dimnames
dimnames(m) <- list(
  c(NULL), # rows, or y-dimension is meaningless, used for ties
  desirable = NULL  # no use in adding actual column names
  # say, desirable is the short form for the sorting conditition used on x
)
grid_byhand <- psGrid(grid = m)

# coerce grid from conventional distribution notation
grid_bycoercion <- as_psGrid(obj = c(1,2,1))
one_sort <- matrix(
  data = c(NA, "live_2_work", NA, "work_2_live", NA, NA),
  nrow = 2,
  dimnames = list(
    c(NULL),
    # this is for rownames, of which there are none, because those are just ties
    desirable = NULL  # no really useful dimnames
    # 'desirable' is a short name for the description of the sorting axis
    # (here, as typically, x)
  )
)
one_sort <- psSort(sort = one_sort)

# you can coerce an empty (all `NA`) sort from grid
as_psSort(obj = grid_bycoercion)

# you can coerce a sort from an integer(ish) vector, with cells filled from the bottom up
one_sort_from_vec <- as_psSort(obj = c(foo = -1, bar = 0, zap = 1, zong = 1))
# you can also pass on other arguments to `psSort()`
one_sort_from_vec_hex <- as_psSort(
  obj = c(foo = -1, bar = 0, zap = 1, zong = 1),
  polygon = "hexagon",
  offset = "odd"
)


}
\concept{S3 classes from `pensieve`.}
